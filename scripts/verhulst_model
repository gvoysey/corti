#!/usr/bin/env python
"""
Verhulst Model.

Usage:
    verhulst_model -h | --help
    verhulst_model --version
    verhulst_model [--out <outpath>]  [-c | --clean]  [-v | --verbose] [--pSave <peripheryFlag>] [--bSave] [--noBrainstem] [(--stimulusFile <stimulusPath> | (--wavFile <wavPath> --level <spl>))] [--no-cf-weighting]

Options:
    -h --help                       Show this screen and exit.
    --version                       Display the version and exit.
    --out=<outpath>                 Specify the output location for saved data. [default: ~/verhulst-output]
    --pSave=<peripheryFlag>         Which components of the peripheral response to save.  [default: cavihlmesd]
    --bSave                         Brainstem output will be saved if set.
    --noBrainstem                   Simulate the periphery only.
    --no-cf-weighting               Do not sigmoidally weight how many low, medium, and high SR fibers innervate each CF.
    --stimulusFile=<stimulusPath>   Provide one or more stimuli templates as YAML (see stimulus_generator --help ).  If no option is provided, a 60dB click will be used.
    --wavFile=<wavPath>             Provide a custom stimulus from a pre-recorded WAV file.
    --level=<spl>                   Specify the peak sound level(s) of the WAV specified with --wavFile.  Separate values with commas.
    -c --clean                      Previous runs will be deleted to save disk space.
    -v --verbose                    Display detailed debug log output to STDOUT.
"""

import os
import shutil
import sys
from datetime import datetime
from logging import info, basicConfig, getLogger, ERROR, INFO
from os import path, system, name

from docopt import docopt

from verhulst_runner import Periphery, Stimulus
from verhulst_runner._version import __version__
from verhulst_runner.analysis.plots import save_summary_pdf
from verhulst_runner.base import runtime_consts
from verhulst_runner.brainstem import simulate_brainstem, AuditoryNerveResponse
from verhulst_runner.periphery_configuration import PeripheryConfiguration

# By default, log INFO and up.
basicConfig(format='%(levelname)s %(asctime)s- %(message)s', datefmt='%d %b %H:%M:%S', level=INFO)


def _sanitize_level(levels: str):
    """ Takes a string list of level parameters and converts them to a list of floats.
    """
    if levels is None:
        return
    return [float(f) for f in levels.split(",") if f]


def main():
    # get the command line args
    args = docopt(__doc__, version=__version__)

    # configure the log level appropriately
    if not args["--verbose"]:
        getLogger().setLevel(ERROR)

    # configure the stimulus
    stim_loc = args["--stimulusFile"]
    wav_path = args["--wavFile"]
    levels = _sanitize_level(args["--level"])
    s = Stimulus()
    if stim_loc:
        # use a user-configured stimulus file.
        stimuli_dict = s.custom_stimulus_template(stim_loc)
    elif not wav_path:
        # use the default stimulus.
        stimuli_dict = s.default_stimulus_template()
    else:
        # use a user-created wav stimulus.
        stimuli_dict = s.load_stimulus(wav_path, levels)
    stimuli_dict = s.generate_stimulus(stimuli_dict)
    # actually run_nc04 the simulation
    system('cls' if name == 'nt' else 'clear')
    info("output directory set to {0}".format(__set_output_dir(args["--out"])))
    conf = PeripheryConfiguration(__set_output_dir(args["--out"]), args["--pSave"], stimuli_dict)

    print("Simulating periphery...")
    peripheryResults = Periphery(conf).run()
    print("Simulating auditory nerve response...")
    degradation = None
    if args["--no-cf-weighting"]:
        auditoryNerveResponses = [AuditoryNerveResponse(p).unweighted_an_response(degradation=degradation) for p in peripheryResults]
    else:
        auditoryNerveResponses = [AuditoryNerveResponse(p).cf_weighted_an_response(degradation=degradation) for p in peripheryResults]

    brainResults = None
    if not args["--noBrainstem"]:
        print("Simulating brainstem response")
        brainResults = simulate_brainstem([(periphs, anrs, args["--bSave"])
                                           for periphs, anrs in zip(peripheryResults, auditoryNerveResponses)])

    print("Generating summary figures")
    save_summary_pdf(peripheryResults, auditoryNerveResponses, brainResults, conf, "summary-plots.pdf",
                     peripheryResults[0].outputFolder)

    if args["--clean"]:
        print("Cleaning old model runs ... ")
        __clean(conf.dataFolder, peripheryResults[0].outputFolder)

    print("Simulation finished.")

    sys.exit(0)


def __clean(rootDir: str, current_results: str) -> None:
    """
    Removes all the previous model runs except the current one found in the current base output directory.
    All directories that are named like model output directories are removed recursively; no other files are touched.
    """
    contents = os.listdir(rootDir)
    if runtime_consts.ModelDirectoryLabelName not in contents:
        info("Specified directory was not a model output directory. No data removed.")
        return
    info("cleaning up...")
    for d in contents:
        if (not d == path.basename(current_results)) and \
                path.isdir(path.join(rootDir, d)) and \
                datetime.strptime(d, runtime_consts.ResultDirectoryNameFormat):
            shutil.rmtree(path.join(rootDir, d))
            info("removed " + d)
    info("cleaned.")
    pass


def __touch(fname, times=None):
    """ As coreutils touch; may not work on windows.
    """
    with open(fname, 'a+'):
        os.utime(fname, times)


def __set_output_dir(temp: str) -> str:
    """ Returns a fully qualified path to the model output root directory.
    The directory is created if it does not exist.
    """
    # just in case we're on windows.
    temp.replace("\\", "\\\\")

    retval = path.realpath(path.join(*path.split(path.expanduser(temp))))
    if path.isfile(retval):
        retval = path.dirname(retval)
    # if the output path exists and is empty, make it the output root and return it.
    if path.exists(retval) and not os.listdir(retval):
        __touch(path.join(retval, runtime_consts.ModelDirectoryLabelName))
        return retval
    # if it exists and has stuff in it, make a subdirectory in it, make IT the root, and return it.
    elif path.exists(retval) and os.listdir(retval):
        if path.basename(retval) != runtime_consts.DefaultModelOutputDirectoryRoot:
            retval = path.join(retval, runtime_consts.DefaultModelOutputDirectoryRoot)
        if not path.exists(retval):
            os.makedirs(retval, exist_ok=True)
        __touch(path.join(retval, runtime_consts.ModelDirectoryLabelName))
        return retval
    # if it doesn't exist, make it, make it the root, and return it.
    elif not path.exists(retval):
        os.makedirs(retval)
        __touch(path.join(retval, runtime_consts.ModelDirectoryLabelName))
        return retval


if __name__ == "__main__":
    sys.exit(main())
